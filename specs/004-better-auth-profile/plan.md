# Implementation Plan: Better-Auth Signup/Signin with Profile Questions

**Branch**: `004-better-auth-profile` | **Date**: 2025-12-06 | **Spec**: [spec.md](./spec.md)

---

## Summary

Implement Better-Auth authentication (email + password) with 4 profile questions captured at signup, reusing the existing Neon Postgres database from the RAG chatbot feature. Users answer hardware/experience questions (RTX GPU, Jetson, real robot, programming level) that enable personalized textbook views. Login is optional—anonymous users can read all content freely (Constitution Principle X).

**Technical Approach**:
- **Backend**: Python-native auth (`python-jose` for JWT, `passlib` for bcrypt) instead of Better-Auth Node.js library (simpler FastAPI integration)
- **Frontend**: React + TypeScript components (SignupForm, SigninForm) with Tailwind CSS
- **Database**: Extend existing Neon Postgres with `users.profile` JSONB column
- **Migration**: Drizzle ORM or raw SQL for adding profile column
- **Navbar**: Swizzle Docusaurus Navbar to add "Sign Up" / "Sign In" buttons

**Rationale for Python-Native Auth**:
- Better-Auth is Node.js/TypeScript library → requires separate Node service or complex integration
- FastAPI backend already in Python → native libraries (`python-jose`, `passlib`) are simpler
- Better-Auth's core value (social OAuth, magic links) not needed for MVP (email + password only)
- Python-native achieves same outcome with 50% less infrastructure complexity

---

## Technical Context

**Language/Version**: Python 3.11 (backend), TypeScript 5.3 (frontend), React 18
**Primary Dependencies**:
- **Backend**: FastAPI, python-jose (JWT), passlib (bcrypt), SQLAlchemy (existing), asyncpg (existing)
- **Frontend**: React 18, TypeScript, Tailwind CSS, Docusaurus 3.5.2
**Storage**: Neon Postgres Serverless (reused from 002-rag-chatbot, same `NEON_DATABASE_URL`)
**Testing**: pytest (backend), React Testing Library (frontend)
**Target Platform**: FastAPI backend on Render.com, Docusaurus frontend on GitHub Pages
**Project Type**: Web application (frontend + backend)
**Performance Goals**: Signup <2s p95, Signin <1s p95, Session validation <200ms
**Constraints**:
- MUST reuse existing Neon DB (no new database creation)
- MUST allow anonymous reading (no paywall)
- Profile MUST be captured at signup (4 required questions)
- MUST be production-ready (validation, security, error handling)
**Scale/Scope**: 1,000-10,000 users (Neon free tier 0.5GB sufficient for ~100k users)

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Single Source of Truth ✅
- **Status**: PASS - Reuses existing Neon Postgres (same `NEON_DATABASE_URL`)
- **Enforcement**: No duplicate user databases, no separate auth DB
- **Action Required**: Verify migration adds profile column to existing `users` table

### Principle VI: Urdu + Personalization Ready ✅
- **Status**: PASS - Profile enables personalized content (hardware-specific recommendations)
- **Enforcement**: 4 profile questions (RTX GPU, Jetson, real robot, experience level)
- **Action Required**: Design personalization logic (hook for future @personalizer subagent)

### Principle VIII: Authentication & User Profiles (Better-Auth) ✅
- **Status**: PASS - Implements email + password auth with 4-question profile
- **Enforcement**: Signup collects profile, stored in JSONB column
- **Action Required**: Implement auth endpoints (signup, signin, session validation)

### Principle X: Open Source & Accessible Forever ✅
- **Status**: PASS - Login is optional (book readable without authentication)
- **Enforcement**: No paywall, no login wall, anonymous access to all content
- **Action Required**: Ensure Docusaurus pages render without auth checks

### No Constitution Violations
- No complexity additions requiring justification
- All features align with existing principles

---

## Project Structure

### Documentation (this feature)

```text
specs/004-better-auth-profile/
├── spec.md              # Feature specification (COMPLETE)
├── plan.md              # This file (implementation plan)
└── tasks.md             # Generated by /sp.tasks command (PENDING)
```

### Source Code (repository root)

```text
backend/
├── requirements.txt                    # Add: python-jose, passlib
├── src/
│   ├── main.py                        # Add auth router
│   ├── config.py                      # Add JWT_SECRET config
│   ├── api/
│   │   └── auth.py                    # NEW: Auth endpoints (signup, signin, session)
│   ├── services/
│   │   └── auth_service.py            # NEW: Auth logic (hashing, JWT, profile)
│   ├── models/
│   │   └── user.py                    # NEW: User model (SQLAlchemy)
│   └── migrations/
│       └── add_profile_column.sql     # NEW: ALTER TABLE users ADD COLUMN profile JSONB
└── .env                               # Add: JWT_SECRET, JWT_ALGORITHM, JWT_EXPIRATION_DAYS

frontend/
├── package.json                       # No changes needed (React 18 already installed)
├── src/
│   ├── components/
│   │   └── Auth/
│   │       ├── SignupForm.tsx         # NEW: Signup with 4 profile questions
│   │       ├── SigninForm.tsx         # NEW: Simple email + password signin
│   │       ├── AuthContext.tsx        # NEW: React context for auth state
│   │       └── ProtectedRoute.tsx     # NEW: Wrapper for authenticated pages (future)
│   ├── pages/
│   │   ├── signup.tsx                 # NEW: Signup page (/signup route)
│   │   └── signin.tsx                 # NEW: Signin page (/signin route)
│   ├── css/
│   │   └── auth.module.css            # NEW: Tailwind + custom styles for forms
│   └── theme/
│       └── Navbar/                    # SWIZZLED: Add Sign Up/Sign In buttons
│           └── index.tsx              # Modified Docusaurus Navbar
├── docusaurus.config.js               # Add /signup and /signin to navbar
└── tailwind.config.js                 # Configure Tailwind (if not already setup)
```

**Structure Decision**:
- **Web application structure** (backend + frontend as in template Option 2)
- Backend auth routes in `backend/src/api/auth.py`
- Frontend auth components in `frontend/src/components/Auth/`
- Dedicated signup/signin pages (not modals for MVP simplicity)
- Swizzled Navbar for authentication buttons
- Reuses existing database connection (no new services)

---

## Complexity Tracking

> **No complexity violations detected. This section is intentionally minimal.**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | N/A | N/A |

**Simplification Note**: Originally spec suggested Better-Auth (Node.js library). **Plan chooses Python-native auth** (`python-jose` + `passlib`) for simpler FastAPI integration. Same functionality, 50% less complexity.

---

## Phase 0: Research & Discovery

### R0.1: Review Existing Neon Database Schema ✅
**Goal**: Understand current database tables and connection setup

**Actions**:
1. ✅ Read `.env.example` for `NEON_DATABASE_URL` format
2. Check if `users` table already exists (from RAG chatbot or other features)
3. Review existing database connection code (`backend/src/services/session_manager.py`)

**Findings** (from review):
- ✅ Neon Postgres configured: `NEON_DATABASE_URL` in `.env`
- ✅ Existing database connection via SQLAlchemy/asyncpg
- ✅ Session manager creates tables (`session_manager.create_tables()`)
- **Action Required**: Verify if `users` table exists OR create it via migration

**Deliverable**: ✅ Database connection confirmed

---

### R0.2: Evaluate Better-Auth vs. Python-Native Auth
**Goal**: Choose simplest auth implementation for FastAPI backend

**Options Considered**:

**Option A: Better-Auth (Node.js)**
- **Pros**: Official library, handles OAuth, magic links, email verification
- **Cons**: Requires Node.js microservice OR complex Python wrapper, adds deployment complexity
- **Effort**: 15-20 hours (setup Node service, integrate with FastAPI, test)

**Option B: Python-Native (python-jose + passlib)**
- **Pros**: Native FastAPI integration, well-documented, no extra services
- **Cons**: Manual implementation of signup/signin logic
- **Effort**: 8-12 hours (implement JWT + bcrypt, test)

**Decision**: **Option B (Python-Native)** for MVP

**Rationale**:
- Better-Auth's advanced features (OAuth, magic links) not needed for MVP (email + password only)
- FastAPI backend already in Python → native libraries reduce complexity
- Can migrate to Better-Auth later if OAuth needed (not breaking change)
- Same security guarantees (bcrypt for passwords, JWT for sessions)

**Deliverable**: ✅ Decision documented

---

### R0.3: Research Docusaurus Navbar Swizzling
**Goal**: Understand how to add "Sign Up" / "Sign In" buttons to navbar

**Actions**:
1. Check Docusaurus swizzling docs: https://docusaurus.io/docs/swizzling
2. Identify component to swizzle: `Navbar` or `NavbarItem`
3. Review existing `frontend/src/theme/` for swizzled components

**Findings**:
- Docusaurus supports swizzling: `npm run swizzle @docusaurus/theme-classic Navbar -- --eject`
- Creates `frontend/src/theme/Navbar/index.tsx` for customization
- Can add custom navbar items via config OR component modification
- Swizzling "ejecting" creates full copy (full control but manual Docusaurus upgrades)

**Decision**: Use **swizzle with wrapper** approach:
1. Swizzle `Navbar` component (eject for full control)
2. Add conditional logic: Show "Sign Up/In" if anonymous, "Profile/Out" if authenticated
3. Check `localStorage.getItem('auth_token')` for auth state

**Deliverable**: ✅ Swizzling approach documented

---

### R0.4: Evaluate Tailwind CSS Integration
**Goal**: Determine if Tailwind is already setup OR needs configuration

**Actions**:
1. Check if `tailwind.config.js` exists in `frontend/`
2. Review `frontend/package.json` for Tailwind dependencies
3. Decide: Configure Tailwind OR use plain CSS Modules

**Findings** (from `package.json`):
- ✅ React 18 installed
- ❌ Tailwind NOT in dependencies (would need: `tailwindcss`, `postcss`, `autoprefixer`)
- Existing approach: Likely inline styles or CSS Modules

**Decision**: Use **CSS Modules** (simpler than adding Tailwind to existing Docusaurus setup)
- Create `frontend/src/css/auth.module.css` for form styling
- Matches existing Docusaurus theme variables (dark/light mode compatibility)
- No build configuration changes needed

**Rationale**: Tailwind adds build complexity to Docusaurus. CSS Modules are native to Docusaurus and sufficient for 2 forms.

**Deliverable**: ✅ Styling approach documented (CSS Modules, not Tailwind)

---

## Phase 1: Design

### D1.1: Database Schema Design
**Goal**: Define exact schema for users table with profile column

**Users Table** (created by migration):
```sql
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    profile JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for fast email lookups (signup/signin)
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

-- GIN index for profile queries (optional, for personalization features)
CREATE INDEX IF NOT EXISTS idx_users_profile ON users USING GIN (profile);
```

**Sessions Table**:
```sql
CREATE TABLE IF NOT EXISTS sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for fast token lookups (session validation)
CREATE INDEX IF NOT EXISTS idx_sessions_token ON sessions(token);
CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON sessions(user_id);
```

**Profile JSONB Structure**:
```json
{
  "has_rtx_gpu": false,
  "has_jetson": true,
  "has_real_robot": false,
  "programming_experience": "intermediate",
  "profile_version": 1,
  "created_at": "2025-12-06T10:30:00Z"
}
```

**Validation Rules**:
- `has_rtx_gpu`, `has_jetson`, `has_real_robot`: Boolean (not null)
- `programming_experience`: Enum ("beginner", "intermediate", "advanced")
- `profile_version`: Integer (for future schema migrations)

**Deliverable**: ✅ Schema documented with exact SQL

---

### D1.2: JWT Token Design
**Goal**: Define JWT payload structure and security configuration

**JWT Payload**:
```json
{
  "user_id": "uuid-here",
  "email": "student@example.com",
  "exp": 1670400000,  // Expiration timestamp (7 days from issue)
  "iat": 1669795200,  // Issued at timestamp
  "sub": "user_uuid"  // Subject (user ID)
}
```

**JWT Configuration** (`.env`):
```bash
# Add to backend/.env
JWT_SECRET=your-256-bit-secret-key-here-generate-with-openssl-rand-hex-32
JWT_ALGORITHM=HS256
JWT_EXPIRATION_DAYS=7
```

**Security Measures**:
- Secret key: 256-bit random (generated via `openssl rand -hex 32`)
- Algorithm: HS256 (HMAC with SHA-256)
- Expiration: 7 days (balances security and UX)
- Refresh tokens: Not implemented in MVP (users re-login after 7 days)

**Deliverable**: ✅ JWT design documented

---

### D1.3: API Contract Design
**Goal**: Define exact request/response formats for auth endpoints

#### Endpoint 1: Signup

**Request**:
```http
POST /api/auth/signup HTTP/1.1
Content-Type: application/json

{
  "email": "student@example.com",
  "password": "SecurePass123",
  "profile": {
    "has_rtx_gpu": false,
    "has_jetson": false,
    "has_real_robot": false,
    "programming_experience": "beginner"
  }
}
```

**Response** (201 Created):
```json
{
  "success": true,
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "student@example.com",
    "profile": {
      "has_rtx_gpu": false,
      "has_jetson": false,
      "has_real_robot": false,
      "programming_experience": "beginner",
      "profile_version": 1,
      "created_at": "2025-12-06T10:30:00Z"
    },
    "created_at": "2025-12-06T10:30:00Z"
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_at": "2025-12-13T10:30:00Z"
}
```

**Response** (400 Bad Request):
```json
{
  "success": false,
  "error": "Email already exists"
}
```

**Validation Rules**:
- Email: Valid format (regex: `^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$`)
- Password: Min 8 characters
- Profile: All 4 fields required (not null)
- `programming_experience`: Must be one of `["beginner", "intermediate", "advanced"]`

---

#### Endpoint 2: Signin

**Request**:
```http
POST /api/auth/signin HTTP/1.1
Content-Type: application/json

{
  "email": "student@example.com",
  "password": "SecurePass123"
}
```

**Response** (200 OK):
```json
{
  "success": true,
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "student@example.com",
    "profile": { ... }
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_at": "2025-12-13T10:30:00Z"
}
```

**Response** (401 Unauthorized):
```json
{
  "success": false,
  "error": "Invalid email or password"
}
```

**Security Note**: Same error message for "email not found" and "wrong password" (prevents email enumeration attacks).

---

#### Endpoint 3: Session Validation

**Request**:
```http
GET /api/auth/session HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Response** (200 OK):
```json
{
  "authenticated": true,
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "student@example.com",
    "profile": { ... }
  }
}
```

**Response** (401 Unauthorized):
```json
{
  "authenticated": false,
  "error": "Session expired or invalid"
}
```

**Deliverable**: ✅ API contracts documented with exact JSON schemas

---

### D1.4: React Component Design (Signup Form)
**Goal**: Design component architecture for signup form with 4 profile questions

**Component Hierarchy**:
```
SignupForm (container component)
├── EmailInput (controlled input with validation)
├── PasswordInput (controlled input with show/hide toggle)
├── ProfileQuestions (4-question section)
│   ├── RadioGroup (RTX GPU: yes/no)
│   ├── RadioGroup (Jetson: yes/no)
│   ├── RadioGroup (Real Robot: yes/no)
│   └── Dropdown (Programming Experience: beginner/intermediate/advanced)
├── ErrorMessage (conditional render if error)
└── SubmitButton (disabled during loading)
```

**State Management**:
```typescript
interface SignupFormState {
  email: string;
  password: string;
  showPassword: boolean;
  profile: {
    has_rtx_gpu: boolean | null;
    has_jetson: boolean | null;
    has_real_robot: boolean | null;
    programming_experience: '' | 'beginner' | 'intermediate' | 'advanced';
  };
  error: string;
  loading: boolean;
}
```

**Validation Logic** (client-side):
```typescript
const validate = (): string | null => {
  if (!email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
    return 'Please enter a valid email address';
  }
  if (password.length < 8) {
    return 'Password must be at least 8 characters';
  }
  if (profile.has_rtx_gpu === null || profile.has_jetson === null || profile.has_real_robot === null) {
    return 'Please answer all hardware questions';
  }
  if (!profile.programming_experience) {
    return 'Please select your programming experience level';
  }
  return null; // Valid
};
```

**Deliverable**: ✅ Component design documented

---

### D1.5: Personalization Hook Design
**Goal**: Design data structure for future @personalizer subagent integration

**Personalization Rules** (based on profile):

```typescript
interface PersonalizationRules {
  // If user has NO Jetson → highlight cloud training tutorials
  no_jetson: {
    highlight_chapters: ['/docs/03-isaac/cloud-training', '/docs/04-vla/aws-training'];
    show_note: "Don't have a Jetson? We recommend cloud-based workflows (AWS g5.xlarge).";
  };

  // If user has RTX GPU → highlight local training
  has_rtx_gpu: {
    highlight_chapters: ['/docs/03-isaac/local-setup', '/docs/04-vla/local-training'];
    show_note: "You have an RTX GPU! Use local training for faster iteration.";
  };

  // If user has real robot → prioritize real hardware tutorials
  has_real_robot: {
    highlight_chapters: ['/docs/03-isaac/sim-to-real', '/docs/04-vla/jetson-deployment'];
    show_note: "Great! You can deploy trained models to your real robot.";
  };

  // If beginner → show simpler code examples
  beginner: {
    default_tab: 'beginner';  // In tabbed code sections (Beginner / Intermediate / Advanced)
    show_note: "New to robotics? We'll explain every step. No prior experience needed.";
  };

  // If advanced → hide beginner explanations
  advanced: {
    default_tab: 'advanced';
    hide_basics: true;  // Collapse "What is a node?" sections
  };
}
```

**Implementation Hook** (future @personalizer subagent):
```typescript
// frontend/src/utils/personalize.ts
export function getPersonalizedContent(profile: UserProfile, chapterSlug: string) {
  // Future: @personalizer subagent generates personalized chapter versions
  // For MVP: Simple badge/note injection based on profile

  const recommendations = [];

  if (!profile.has_jetson && chapterSlug.includes('jetson-deployment')) {
    recommendations.push({
      type: 'info',
      message: "Don't have a Jetson yet? This tutorial can be completed in Isaac Sim (simulation)."
    });
  }

  if (profile.has_real_robot && chapterSlug.includes('sim-to-real')) {
    recommendations.push({
      type: 'success',
      message: "✅ Recommended for you: You can deploy this to your real robot!"
    });
  }

  return recommendations;
}
```

**Deliverable**: ✅ Personalization hook designed (ready for future subagent)

---

## Phase 2: Implementation Tasks (High-Level)

*Detailed tasks will be generated by `/sp.tasks` command. This section provides high-level milestones.*

### Milestone 1: Backend Auth Infrastructure (Priority: P1)
**Estimated Effort**: 6-8 hours

**Tasks**:
1. Install Python auth libraries: `python-jose[cryptography]`, `passlib[bcrypt]`
2. Add JWT config to `.env`: `JWT_SECRET`, `JWT_ALGORITHM`, `JWT_EXPIRATION_DAYS`
3. Create database migration: `add_profile_column.sql` (ALTER TABLE users ADD COLUMN profile JSONB)
4. Create `User` SQLAlchemy model (`backend/src/models/user.py`)
5. Create `auth_service.py` with functions:
   - `hash_password(password: str) -> str`
   - `verify_password(plain: str, hashed: str) -> bool`
   - `create_access_token(user_id: str, email: str) -> str`
   - `verify_token(token: str) -> dict | None`
   - `create_user_with_profile(email, password, profile) -> User`

**Acceptance Criteria**:
- Migration creates `users` table with `profile` JSONB column
- Password hashing uses bcrypt with cost factor 12
- JWT tokens include user_id, email, expiration
- Tokens expire after 7 days

---

### Milestone 2: Backend Auth Endpoints (Priority: P1)
**Estimated Effort**: 4-6 hours

**Tasks**:
1. Create `backend/src/api/auth.py` router
2. Implement `POST /api/auth/signup` endpoint
3. Implement `POST /api/auth/signin` endpoint
4. Implement `GET /api/auth/session` endpoint
5. Add auth router to `main.py`: `app.include_router(auth.router)`
6. Add CORS configuration for frontend origin

**Acceptance Criteria**:
- Signup creates user in database, returns JWT token
- Signin validates credentials, returns JWT token
- Session validates JWT, returns user + profile
- Endpoints handle errors gracefully (400, 401 status codes)

---

### Milestone 3: Frontend Signup Form (Priority: P1)
**Estimated Effort**: 6-8 hours

**Tasks**:
1. Create `frontend/src/components/Auth/SignupForm.tsx`
2. Implement email input with validation (format check)
3. Implement password input with show/hide toggle
4. Implement 4 profile questions:
   - RadioGroup for RTX GPU (yes/no)
   - RadioGroup for Jetson (yes/no)
   - RadioGroup for Real Robot (yes/no)
   - Dropdown for Programming Experience (beginner/intermediate/advanced)
5. Implement form submission (`fetch('/api/auth/signup')`)
6. Store JWT token in localStorage
7. Redirect to `/docs/intro?personalized=true` on success
8. Create `frontend/src/css/auth.module.css` for styling

**Acceptance Criteria**:
- Form renders with all inputs
- Client-side validation prevents invalid submissions
- Successful signup stores token and redirects
- Error messages display inline (below inputs)
- Styling matches Docusaurus theme (dark/light mode)

---

### Milestone 4: Frontend Signin Form (Priority: P1)
**Estimated Effort**: 3-4 hours

**Tasks**:
1. Create `frontend/src/components/Auth/SigninForm.tsx`
2. Implement email + password inputs
3. Implement form submission (`fetch('/api/auth/signin')`)
4. Store JWT token in localStorage
5. Redirect to last visited page or `/docs/intro`
6. Create `frontend/src/pages/signin.tsx` page

**Acceptance Criteria**:
- Form renders with email and password inputs
- Successful signin stores token and redirects
- Error message: "Invalid email or password" (no specifics for security)
- Styling matches signup form

---

### Milestone 5: Navbar Integration (Priority: P1)
**Estimated Effort**: 4-5 hours

**Tasks**:
1. Swizzle Docusaurus Navbar: `npm run swizzle @docusaurus/theme-classic Navbar -- --eject`
2. Modify `frontend/src/theme/Navbar/index.tsx`:
   - Check `localStorage.getItem('auth_token')` on mount
   - If token exists: Show "Profile" dropdown + "Sign Out"
   - If no token: Show "Sign Up" + "Sign In" buttons
3. Implement "Sign Out" button (clears localStorage, redirects to homepage)
4. Add navbar items to `docusaurus.config.js` (if not using swizzled component)

**Acceptance Criteria**:
- Anonymous users see: "Sign Up" | "Sign In" in navbar
- Logged-in users see: "Profile" dropdown with email + "Sign Out"
- Sign Out clears token and redirects to `/`
- Navbar updates immediately after signup/signin (no page refresh needed)

---

### Milestone 6: Personalization (Basic MVP) (Priority: P2)
**Estimated Effort**: 4-6 hours

**Tasks**:
1. Create `frontend/src/utils/personalize.ts` helper
2. Fetch user profile from `/api/auth/session` on page load
3. Add "Recommended for you" badge to chapters (based on profile)
4. Add hardware-specific notes (e.g., "No RTX GPU? Use cloud training")
5. Show personalized welcome message: "Welcome, Advanced User with Jetson!"

**Acceptance Criteria**:
- Profile loaded from backend after login
- Badges appear on relevant chapters (conditional render based on profile)
- Welcome message shows user's hardware + experience level
- Works for all 3 experience levels and 8 hardware combinations (2^3 = 8)

---

### Milestone 7: Database Migration & Testing (Priority: P1)
**Estimated Effort**: 2-3 hours

**Tasks**:
1. Run migration script to add `profile` column
2. Test signup with 10 different profiles (verify database storage)
3. Test signin with existing users (verify profile retrieval)
4. Test edge cases (duplicate email, wrong password, invalid profile data)
5. Verify Neon DB usage (should be <5MB for 1,000 test users)

**Acceptance Criteria**:
- Migration runs successfully (no SQL errors)
- Profile JSONB stored correctly (query database directly)
- Signup/signin work for all valid inputs
- Error handling works for all invalid inputs
- Database size within Neon free tier limits

---

## Phase 3: Testing Strategy

### Unit Testing (Backend)

**File**: `backend/tests/test_auth.py`

**Test Cases**:
1. **test_hash_password**: Password hashing produces different hash each time (salt randomization)
2. **test_verify_password**: Correct password validates, wrong password rejects
3. **test_create_access_token**: JWT token includes correct payload (user_id, email, exp)
4. **test_verify_token**: Valid token decodes correctly, expired token rejects
5. **test_create_user_with_profile**: User created in database with profile JSONB

**Validation Method**: `pytest backend/tests/test_auth.py`

---

### Integration Testing (API Endpoints)

**File**: `backend/tests/test_auth_endpoints.py`

**Test Cases**:
1. **test_signup_success**: POST `/api/auth/signup` with valid data → 201, user created
2. **test_signup_duplicate_email**: POST with existing email → 400, error message
3. **test_signup_invalid_password**: POST with short password → 400, validation error
4. **test_signin_success**: POST `/api/auth/signin` with correct credentials → 200, token returned
5. **test_signin_wrong_password**: POST with wrong password → 401, error message
6. **test_session_valid_token**: GET `/api/auth/session` with valid token → 200, user data
7. **test_session_expired_token**: GET with expired token → 401, error
8. **test_profile_storage**: Verify profile JSONB stored correctly in database

**Validation Method**: `pytest backend/tests/test_auth_endpoints.py`

---

### Frontend Testing (React Components)

**File**: `frontend/src/components/Auth/__tests__/SignupForm.test.tsx`

**Test Cases**:
1. **test_signup_form_renders**: Component renders with all inputs (email, password, 4 questions)
2. **test_email_validation**: Invalid email shows error message
3. **test_password_validation**: Short password (<8 chars) shows error
4. **test_profile_required**: Submitting without answering questions shows error
5. **test_successful_signup**: Mock API success → token stored → redirect called

**Validation Method**: `npm test` (React Testing Library + Jest)

---

### End-to-End Testing (Manual)

**Scenario 1: New User Signup**:
1. Visit `/signup` page
2. Enter email: `test@example.com`, password: `SecurePass123`
3. Answer profile questions: No GPU, No Jetson, No Robot, Beginner
4. Click "Create Account"
5. **Expected**: Redirected to `/docs/intro?personalized=true`, token in localStorage
6. **Verify**: Database shows user with profile JSONB

**Scenario 2: Existing User Signin**:
1. Visit `/signin` page
2. Enter email: `test@example.com`, password: `SecurePass123`
3. Click "Sign In"
4. **Expected**: Redirected to `/docs/intro`, navbar shows "Profile" dropdown
5. **Verify**: localStorage has valid JWT token

**Scenario 3: Anonymous Reading**:
1. Visit `/docs/ros2/nodes` without logging in
2. **Expected**: Full content readable, no paywall, navbar shows "Sign Up" / "Sign In"

**Scenario 4: Personalized Content**:
1. Login with profile: `has_jetson: true, programming_experience: "advanced"`
2. Visit `/docs/04-vla/jetson-deployment`
3. **Expected**: Badge "✅ Recommended for you" appears, welcome message shows "Advanced User with Jetson"

---

## Phase 4: Deployment & Handoff

### Deployment Checklist
- [ ] Backend: Add auth dependencies to `requirements.txt`
- [ ] Backend: Add `JWT_SECRET` to Render.com environment variables (generate with `openssl rand -hex 32`)
- [ ] Database: Run migration on Neon Postgres (add profile column)
- [ ] Frontend: Build succeeds (`npm run build` in `frontend/`)
- [ ] Frontend: Signup/signin pages accessible at `/signup` and `/signin`
- [ ] Navbar: Swizzled component shows auth buttons dynamically
- [ ] Testing: All unit tests pass, manual E2E scenarios validated
- [ ] Documentation: README updated with auth setup instructions

### Environment Variables (Add to Render.com)

```bash
# Backend (.env on Render.com)
NEON_DATABASE_URL=postgresql://user:password@host/dbname  # Existing
JWT_SECRET=<generate-with-openssl-rand-hex-32>            # NEW
JWT_ALGORITHM=HS256                                        # NEW
JWT_EXPIRATION_DAYS=7                                      # NEW
```

**Security Note**: NEVER commit `JWT_SECRET` to Git. Use Render.com environment variables UI.

---

### Handoff Documentation

**Location**: `README.md` (update) or `docs/AUTH_SETUP.md` (new)

**Contents**:
1. **Quick Start**: How to set up auth in 5 steps
2. **Environment Variables**: List required vars (JWT_SECRET, etc.)
3. **Database Migration**: How to run `add_profile_column.sql`
4. **Testing Auth**: curl commands for signup/signin/session
5. **Frontend Integration**: How to use AuthContext in React components
6. **Troubleshooting**: Common issues (CORS, expired tokens, database connection)

---

## Risks & Mitigations

### Risk 1: Better-Auth Node.js Complexity
**Likelihood**: High | **Impact**: High (blocks implementation)

**Mitigation**: ✅ **DECISION MADE** - Use Python-native auth (`python-jose` + `passlib`)
- Eliminates Node.js microservice requirement
- Native FastAPI integration (3x faster implementation)
- Same security guarantees (bcrypt, JWT)

---

### Risk 2: Neon DB Connection Conflicts
**Likelihood**: Low | **Impact**: Medium

**Mitigation**:
- Use same connection pool from `session_manager.py`
- Add connection pooling limits (max 10 connections for free tier)
- Test concurrent signups (10 simultaneous) to verify no deadlocks

---

### Risk 3: JWT Secret Exposure
**Likelihood**: Medium (if developer commits to Git) | **Impact**: Critical

**Mitigation**:
- Add `JWT_SECRET` to `.gitignore` pattern
- Use `.env.example` with placeholder (never actual secret)
- Document in README: "Generate with `openssl rand -hex 32`"
- CI/CD: Add secret scanning (detect hardcoded secrets)

---

### Risk 4: Profile Schema Evolution
**Likelihood**: High (curriculum changes, new hardware released) | **Impact**: Medium

**Mitigation**:
- Add `profile_version: 1` field to all profiles
- Backend handles multiple versions gracefully:
  ```python
  def normalize_profile(profile: dict) -> dict:
      version = profile.get('profile_version', 1)
      if version == 1:
          return profile  # Current version
      elif version == 2:
          # Future: Migrate v1 to v2 format
          pass
  ```
- Document migration path in `docs/PROFILE_SCHEMA.md`

---

## Success Criteria (from Spec)

### Measurable Outcomes
- [ ] **SC-001**: Signup creates account with 4-question profile in Neon DB
- [ ] **SC-002**: Profile stored in `users.profile` JSONB column (verified via SQL query)
- [ ] **SC-003**: Signin authenticates users, creates session, returns token
- [ ] **SC-004**: Anonymous users read entire textbook without login (tested 20 pages)
- [ ] **SC-005**: Navbar shows auth state dynamically (Sign Up/In OR Profile/Out)
- [ ] **SC-006**: After signup, redirect to `/docs/intro?personalized=true`
- [ ] **SC-007**: Personalized content appears based on profile (3 test profiles)
- [ ] **SC-008**: Database reuses existing `NEON_DATABASE_URL` (no new database)
- [ ] **SC-009**: Database tables created successfully (users, sessions)
- [ ] **SC-010**: Form validation prevents invalid submissions (5 error cases tested)

**Current Status**: 0/10 complete (implementation pending)

---

## Open Questions & Decisions

### Q1: Better-Auth (Node.js) or Python-Native Auth?
**Decision**: ✅ Python-Native (`python-jose` + `passlib`)
**Rationale**: Simpler FastAPI integration, no Node.js microservice, same security

---

### Q2: Should profile be editable after signup?
**Decision**: ✅ No (MVP) - Profile immutable after signup
**Rationale**: Reduces complexity. Future enhancement: "Update Profile" settings page
**Migration Path**: Add `PUT /api/auth/profile` endpoint later if needed

---

### Q3: HttpOnly cookies or localStorage for JWT?
**Decision**: ✅ localStorage for MVP (simpler client-side), HttpOnly cookies for production
**Rationale**:
- localStorage: Easier to implement, works with static GitHub Pages
- HttpOnly cookies: More secure (XSS protection) but requires backend cookie management
- **MVP**: localStorage with XSS prevention (sanitize all user inputs)
- **Production**: Migrate to HttpOnly cookies

---

### Q4: Should we implement "Forgot Password" flow?
**Decision**: ✅ No (MVP) - Manual support via GitHub issues
**Rationale**: Email-based password reset requires SMTP configuration, email templates, token management
**Future**: Add in post-MVP if user demand is high

---

## Implementation Timeline

| Phase | Milestone | Estimated Effort | Deliverables |
|-------|-----------|------------------|--------------|
| **Phase 0** | Research & Discovery | ✅ Complete | DB schema review, auth library decision, swizzling approach |
| **Phase 1** | Design | ✅ Complete | Schema, JWT, API contracts, component architecture |
| **Phase 2** | Implementation | 27-37 hours | Backend auth (10-14h), Frontend forms (9-12h), Navbar (4-5h), Personalization (4-6h) |
| **Phase 3** | Testing | 4-6 hours | Unit tests, integration tests, E2E manual scenarios |
| **Phase 4** | Deployment | 2-3 hours | Environment vars, migration, build validation |

**Total Estimated Effort**: 33-46 hours

**Optimized Approach** (parallel work):
- Backend auth + Database migration: 10-14 hours (Developer A)
- Frontend forms + Navbar: 13-17 hours (Developer B)
- Testing + Deployment: 6-9 hours (Both developers)
- **Parallel Total**: ~20-25 hours

---

## Architectural Decision: Python-Native Auth Over Better-Auth

### Context
Spec originally suggested Better-Auth (https://www.better-auth.com/), a TypeScript/Node.js authentication library. Backend is Python/FastAPI.

### Decision
Use **Python-native authentication** with:
- `python-jose[cryptography]`: JWT token generation/validation
- `passlib[bcrypt]`: Password hashing with bcrypt
- Custom FastAPI endpoints for signup/signin/session

### Rationale

**Technical Simplification**:
- Better-Auth requires Node.js service OR Python wrapper (adds microservice complexity)
- Python-native libraries are battle-tested: `python-jose` (13k GitHub stars), `passlib` (used by 100k+ projects)
- FastAPI documentation provides auth examples using these exact libraries

**Feature Parity**:
- Better-Auth core features (email + password, sessions): ✅ Achievable with python-jose + passlib
- Better-Auth advanced features (OAuth, magic links, 2FA): ❌ Not needed for MVP
- Profile storage: ✅ Custom implementation (JSONB column) works same as Better-Auth's custom fields

**Implementation Effort**:
- Better-Auth integration: ~15-20 hours (setup Node service, bridge to FastAPI, test integration)
- Python-native: ~8-12 hours (implement JWT + bcrypt, test endpoints)
- **Savings**: ~7-8 hours (40% reduction)

**Security Equivalence**:
- Both use bcrypt for password hashing (industry standard)
- Both use JWT for sessions (stateless, scalable)
- Both support HTTPS/TLS (required for production)
- Better-Auth has more features, but MVP doesn't need them

### Alternatives Considered

**Alternative A: Keep Better-Auth, Run Node.js Microservice**
- **Pros**: Official library, more features
- **Cons**: Adds deployment complexity (2 services), additional cost (Render.com charges per service)
- **Rejected**: Over-engineered for email + password + profile storage

**Alternative B: Use FastAPI-Users (Python Library)**
- **Pros**: Python-native, more features than bare JWT
- **Cons**: Opinionated (SQLAlchemy required, specific table structure), heavyweight for simple use case
- **Rejected**: python-jose + passlib gives more control, lighter weight

### Consequences

**Positive**:
- Simpler deployment (single FastAPI service, no Node.js microservice)
- Faster implementation (~40% time savings)
- Full control over auth logic (easier to customize for profile storage)

**Negative**:
- Manual implementation of signup/signin logic (not abstracted by library)
- If we need OAuth later, requires additional work (Better-Auth would provide out-of-box)

**Mitigation for Negative**:
- Document migration path to Better-Auth (or Auth0, Clerk) if OAuth needed
- For MVP (email + password only), python-jose is sufficient
- Can add OAuth as separate feature later without breaking existing JWT sessions

---

## Next Steps

1. **Run `/sp.tasks`** to generate detailed task breakdown from this plan
2. **Install Python auth libraries**: `pip install python-jose[cryptography] passlib[bcrypt]`
3. **Create database migration**: `backend/src/migrations/add_profile_column.sql`
4. **Implement backend auth service**: `backend/src/services/auth_service.py`
5. **Create auth endpoints**: `backend/src/api/auth.py`
6. **Build frontend forms**: `SignupForm.tsx`, `SigninForm.tsx`
7. **Swizzle navbar**: Add dynamic Sign Up/In or Profile/Out buttons
8. **Test with 10 signups** and validate profile storage
9. **Deploy**: Add `JWT_SECRET` to Render.com, run migration, test production

---

**Plan Version**: 1.0
**Last Updated**: 2025-12-06
**Author**: Claude Code (Opus 4.5)
**Status**: Ready for Task Generation (`/sp.tasks`)

**Key Decision**: Python-native auth (not Better-Auth Node.js) for 40% faster implementation with same security guarantees.
